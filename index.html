<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"></meta>
    <title>Babylon Template</title>

    <link href="style.css" rel="stylesheet">
    <script src="babylon.js"></script>
</head>

<body>

<canvas id="render-canvas" touch-action="none"></canvas> <!-- touch-action="none" for best results from PEP -->

	<script>

        let scene = undefined;
        let camera = undefined;
        let mainLight = undefined;

        // Gets the canvas, engine and scene
        const canvas = document.getElementById("render-canvas");
        const engine = new BABYLON.Engine(canvas);

        createScene();
        createCamera();
        createLights();
        createGround();
        populateScene();
        engine.runRenderLoop(renderLoop);

        function createScene(){
            scene = new BABYLON.Scene(engine);
            scene.clearColor = new BABYLON.Color3(0.8, 0.8, 0.8);
        }

        function createCamera(){
            const distance = 100;
            const target = new BABYLON.Vector3(0, 0, 0);
            camera = new BABYLON.ArcRotateCamera("Camera", 0, 0, distance, target, scene);
            camera.setPosition(new BABYLON.Vector3(0, 100, -100));
            camera.attachControl(canvas, true);
        }

        function createLights(){
            // mainLight = new BABYLON.PointLight("light", new BABYLON.Vector3(10, 10, 0), scene);
            mainLight = new BABYLON.HemisphericLight("hemi", new BABYLON.Vector3(0, 1, 0), scene);
        }

        function createGround(){
            // Part 1 : Creation of Tiled Ground
            // Parameters
            const xmin = -100;
            const zmin = -100;
            const xmax =  100;
            const zmax =  100;
            const precision = {
                "h" : 2,
                "w" : 2
            };
            const subdivisions = {
                'h' : 8,
                'w' : 8
            };
            // Create the Tiled Ground
            const tiledGround = new BABYLON.Mesh.CreateTiledGround("Tiled Ground", xmin, zmin, xmax, zmax, subdivisions, precision, scene);

            // Create Multi Material
            const multimat = new BABYLON.MultiMaterial("multi", scene);
            const zoom = 12;
            const xTileBase = 2120;
            const yTileBase = 1498;
            for (let row = 0; row < subdivisions.h; row++) {
                for (let col = 0; col < subdivisions.w; col++) {
                    const material = new BABYLON.StandardMaterial(
                        "material" + row + "-" + col,
                        scene
                    );
                    material.diffuseTexture = new BABYLON.Texture(
                        "http://b.tile.openstreetmap.org/" + zoom + "/" + (xTileBase + col) + "/" + (yTileBase - row) + ".png",
                        scene
                    );
                    material.diffuseTexture.wrapU = BABYLON.Texture.CLAMP_ADDRESSMODE;
                    material.diffuseTexture.wrapV = BABYLON.Texture.CLAMP_ADDRESSMODE;
                    material.specularColor = new BABYLON.Color4(0, 0, 0, 0);
                    material.backFaceCulling = false;
                    multimat.subMaterials.push(material);
                }
            }


            // Part 3 : Apply the multi material
            // Define multimat as material of the tiled ground
            tiledGround.material = multimat;

            // Needed variables to set subMeshes
            const verticesCount = tiledGround.getTotalVertices();
            const tileIndicesLength = tiledGround.getIndices().length / (subdivisions.w * subdivisions.h);

            // Set subMeshes of the tiled ground
            tiledGround.subMeshes = [];
            let index = 0;
            let base = 0;
            for (var row = 0; row < subdivisions.h; row++) {
                for (let col = 0; col < subdivisions.w; col++) {
                    let submesh = new BABYLON.SubMesh(
                        index++, 0, verticesCount, base , tileIndicesLength, tiledGround
                    );
                    tiledGround.subMeshes.push(submesh);
                    base += tileIndicesLength;
                }
            }
        }

        function populateScene(){
            let cylinderMaterial = new BABYLON.StandardMaterial("material", scene);
            cylinderMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
            cylinderMaterial.specularColor = new BABYLON.Color3(1.0, 0.0, 0.0);

            let cylinder = BABYLON.Mesh.CreateCylinder("cylinder", 3, 3, 3, 20, 1, scene);

        }

        function renderLoop(){
            scene.render();
        }

	</script>

</body>

</html>
